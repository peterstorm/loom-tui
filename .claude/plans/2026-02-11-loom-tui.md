# Architecture Plan: loom-tui

**Spec:** 2026-02-11-loom-tui
**Date:** 2026-02-11
**Status:** Draft

---

## Summary

Rust TUI dashboard for passive monitoring of Claude Code multi-agent orchestration. Elm Architecture (Model/Update/View) with functional core and imperative shell. Three async event sources (file watcher, keyboard, tick) merge into a single channel driving pure `update(state, event) -> state` and `render(&state) -> Frame` functions. Targets 90%+ unit testable code without mocks.

---

## Architectural Decisions

### AD-1: Elm Architecture (TEA) for State Management

**Decision:** Single `AppState` struct updated via pure `fn update(state: AppState, event: AppEvent) -> AppState`. No mutation, no side effects in core logic.

**Rationale:** Deterministic state transitions are trivially testable. Given known state + event, assert exact output state. Eliminates need for mocks. Aligns with FP principles (pure functions, immutability).

**Trade-offs:** Cloning state on every update has allocation cost. Mitigated by `Rc`/`Arc` for large collections (event buffer, transcript data) and structural sharing where beneficial. For a TUI at 4Hz tick rate, this is negligible.

### AD-2: Tokio mpsc Channel as Event Bus

**Decision:** All event sources (notify file watcher, crossterm keyboard, tick timer) send `AppEvent` variants through a single `tokio::sync::mpsc` channel. Main loop receives and dispatches.

**Rationale:** Unified event handling. Single point of control flow. Easy to test by injecting synthetic events. No shared mutable state between producers.

**Alternatives considered:**
- **Multiple channels with select!** -- more complex, no benefit since all feed same update fn
- **Crossbeam channel** -- unnecessary, tokio mpsc sufficient and already in dependency tree

### AD-3: Watcher Layer as Imperative Shell

**Decision:** File watchers (notify), keyboard reader (crossterm), and tick timer live in `watcher/` module. They own I/O, parse raw data, and emit typed `AppEvent` variants. This is the only layer that performs I/O.

**Rationale:** Isolates all side effects. Core logic never touches filesystem. Watchers are thin: read file, parse, emit event. Integration-testable with fixture files.

### AD-4: Immutable Domain Models with Enums for States

**Decision:** Use Rust enums (sum types) for all domain states: `TaskStatus`, `ReviewStatus`, `HookEventKind`, `ViewState`, `PanelFocus`. Use structs with owned data for value objects. No `RefCell`, no interior mutability in model layer.

**Rationale:** Exhaustive match forces handling all variants. Compiler catches missing cases. Aligns with "make invalid states unrepresentable" principle.

### AD-5: View Functions as Pure Rendering

**Decision:** Each view (`dashboard`, `agent_detail`, `sessions`) is a pure function `fn render(state: &AppState, frame: &mut Frame, area: Rect)`. Views read state, produce ratatui widget tree. No state mutation, no I/O.

**Rationale:** Views become snapshot-testable. Given state, assert rendered output contains expected widgets/text. Separation of rendering from state logic.

### AD-6: Ring Buffer for Event Stream

**Decision:** Events stored in `VecDeque<HookEvent>` with capacity 10,000 (FR: NFR-005). Oldest events evicted on overflow. No disk persistence for live events (archived on session end).

**Rationale:** Bounded memory. O(1) push/pop. Simple eviction. Session archiving handles persistence.

### AD-7: Session Archive as JSON Files

**Decision:** Each archived session stored as `~/.local/share/loom-tui/sessions/{timestamp}-{id}.json` containing session metadata + snapshot of task graph + event summary. Individual files, not a database.

**Rationale:** Simple, no external dependencies, easy to inspect/delete. Filesystem is the database. Session list loads by scanning directory and reading metadata from file headers.

### AD-8: Debounced File Watching

**Decision:** File change events debounced at 100ms in watcher layer before parsing and emitting AppEvent. Prevents rapid successive reads of partially-written files.

**Rationale:** Addresses NFR-012 (race conditions on rapid updates). Notify may fire multiple events for single logical write. Debounce collapses to one read.

### AD-9: Graceful Degradation on Parse Errors

**Decision:** All parsers return `Result`. Parse failures logged to internal error buffer (shown in status bar) but never crash the application. Malformed files are skipped with last-known-good state retained.

**Rationale:** NFR-010, NFR-011 require crash resilience. Real-world state files may be partially written, corrupted, or in unexpected format.

### AD-10: Cross-Platform Temp Path Resolution

**Decision:** Use `std::env::var("TMPDIR").unwrap_or("/tmp".into())` for event file paths. Consistent with FR-022.

**Rationale:** macOS sets `$TMPDIR` to user-specific temp dir. Linux typically has `/tmp`. This handles both.

---

## File Structure

```
loom-tui/
  Cargo.toml
  flake.nix
  hooks/
    send_event.sh              # Hook script (bash, installed to .claude/hooks/)
  src/
    main.rs                    # Entry point, arg parsing, event loop (imperative shell)
    lib.rs                     # Re-exports for testing
    app/
      mod.rs                   # AppState struct, top-level update dispatch
      state.rs                 # AppState definition, constructors
      update.rs                # Pure update(state, event) -> state logic
      navigation.rs            # View switching, focus, drill-down logic (pure)
    event/
      mod.rs                   # AppEvent enum definition
    model/
      mod.rs                   # Re-exports
      task.rs                  # Task, Wave, TaskStatus, ReviewStatus, TaskGraph
      agent.rs                 # Agent, ToolCall, AgentMessage, MessageKind
      hook_event.rs            # HookEvent, HookEventKind (all 9 types)
      session.rs               # SessionMeta, SessionArchive, SessionStatus
      theme.rs                 # Color constants, Style definitions
    watcher/
      mod.rs                   # Watcher trait/setup, spawn_all helper
      task_graph.rs            # Watch + parse active_task_graph.json -> AppEvent
      transcripts.rs           # Watch + parse agent-*.jsonl -> AppEvent
      hook_events.rs           # Tail /tmp/loom-tui/events.jsonl -> AppEvent
      active_agents.rs         # Watch /tmp/claude-subagents/*.active -> AppEvent
    view/
      mod.rs                   # View dispatch (match ViewState -> render fn)
      dashboard.rs             # Dashboard layout: header + wave river + tasks + events
      agent_detail.rs          # Agent detail: tool calls + reasoning panels
      sessions.rs              # Sessions table view
      components/
        mod.rs                 # Re-exports
        header.rs              # Top bar: app name, active agents, wave progress
        footer.rs              # Bottom bar: keybindings for current view
        wave_river.rs          # Segmented progress bar per wave
        task_list.rs           # Task panel with wave grouping, status markers
        event_stream.rs        # Scrolling event feed with timestamps
        tool_call_list.rs      # Agent tool call timeline with tree-style results
        reasoning_panel.rs     # Agent reasoning text display
        session_table.rs       # Sessions table with metadata columns
        banner.rs              # Non-blocking notification banner (hook install prompt)
        filter_bar.rs          # Filter/search input overlay
        help_overlay.rs        # ? keybind help overlay
    archive/
      mod.rs                   # Session archive read/write (I/O boundary)
      writer.rs                # Save session snapshot to disk
      reader.rs                # Load session list + individual sessions from disk
    hook_install/
      mod.rs                   # Hook detection + installation logic (I/O boundary)
    paths.rs                   # Path resolution (tmpdir, state dir, archive dir)
  tests/
    fixtures/
      active_task_graph.json   # Sample task graph
      agent-a04.jsonl          # Sample agent transcript
      events.jsonl             # Sample hook events
      session_archive.json     # Sample archived session
    update_tests.rs            # Unit tests for update logic
    navigation_tests.rs        # Unit tests for navigation state transitions
    model_tests.rs             # Unit tests for model parsing/construction
    view_tests.rs              # Snapshot/assertion tests for view rendering
    watcher_integration.rs     # Integration tests for file watching
    archive_integration.rs     # Integration tests for session archiving
```

---

## Component Design

### AppEvent (event/mod.rs)

```rust
pub enum AppEvent {
    // File watcher events
    TaskGraphUpdated(TaskGraph),
    TranscriptUpdated { agent_id: String, messages: Vec<AgentMessage> },
    HookEventReceived(HookEvent),
    AgentStarted(String),      // agent id
    AgentStopped(String),      // agent id

    // Keyboard events
    Key(KeyEvent),

    // Timer
    Tick,

    // Errors (non-fatal)
    ParseError { source: String, error: String },

    // Session management
    SessionLoaded(SessionArchive),
    SessionListRefreshed(Vec<SessionMeta>),
}
```

### AppState (app/state.rs)

```rust
pub struct AppState {
    pub view: ViewState,
    pub task_graph: Option<TaskGraph>,
    pub agents: BTreeMap<String, Agent>,
    pub events: VecDeque<HookEvent>,
    pub sessions: Vec<SessionMeta>,
    pub active_session: Option<SessionMeta>,
    pub focus: PanelFocus,
    pub scroll_offsets: ScrollState,
    pub auto_scroll: bool,
    pub filter: Option<String>,
    pub show_help: bool,
    pub hook_status: HookStatus,
    pub errors: VecDeque<String>,
    pub started_at: Instant,
}

pub enum ViewState {
    Dashboard,
    AgentDetail { agent_id: String },
    Sessions,
}

pub enum PanelFocus {
    Left,
    Right,
}

pub enum HookStatus {
    Unknown,
    Installed,
    Missing,
    InstallFailed(String),
}
```

### Domain Models (model/)

```rust
// model/task.rs
pub struct TaskGraph {
    pub waves: Vec<Wave>,
    pub total_tasks: usize,
    pub completed_tasks: usize,
}

pub struct Wave {
    pub number: u32,
    pub tasks: Vec<Task>,
}

pub struct Task {
    pub id: String,
    pub description: String,
    pub agent_id: Option<String>,
    pub status: TaskStatus,
    pub review_status: ReviewStatus,
    pub files_modified: Vec<String>,
    pub tests_passed: Option<bool>,
}

pub enum TaskStatus {
    Pending,
    Running,
    Implemented,
    Completed,
    Failed { reason: String, retry_count: u32 },
}

pub enum ReviewStatus {
    Pending,
    Passed,
    Blocked { critical: Vec<String>, advisory: Vec<String> },
}

// model/agent.rs
pub struct Agent {
    pub id: String,
    pub task_id: Option<String>,
    pub started_at: DateTime<Utc>,
    pub finished_at: Option<DateTime<Utc>>,
    pub messages: Vec<AgentMessage>,
}

pub struct AgentMessage {
    pub timestamp: DateTime<Utc>,
    pub kind: MessageKind,
}

pub enum MessageKind {
    Reasoning(String),
    Tool(ToolCall),
}

pub struct ToolCall {
    pub tool_name: String,
    pub input_summary: String,
    pub result_summary: Option<String>,
    pub duration: Option<Duration>,
    pub success: Option<bool>,
}

// model/hook_event.rs
pub struct HookEvent {
    pub timestamp: DateTime<Utc>,
    pub kind: HookEventKind,
    pub session_id: Option<String>,
    pub agent_id: Option<String>,
    pub raw: serde_json::Value,
}

pub enum HookEventKind {
    SessionStart,
    SessionEnd,
    SubagentStart { task_description: Option<String> },
    SubagentStop,
    PreToolUse { tool_name: String, input_summary: String },
    PostToolUse { tool_name: String, result_summary: String, duration_ms: Option<u64> },
    Stop { reason: Option<String> },
    Notification { message: String },
    UserPromptSubmit,
}

// model/session.rs
pub struct SessionMeta {
    pub id: String,
    pub timestamp: DateTime<Utc>,
    pub duration: Option<Duration>,
    pub status: SessionStatus,
    pub agent_count: u32,
    pub task_count: u32,
    pub event_count: u32,
    pub project_path: String,
    pub git_branch: Option<String>,
    pub loom_plan_id: Option<String>,
    pub wave_count: Option<u32>,
    pub failed_tasks: Vec<String>,
}

pub enum SessionStatus {
    Active,
    Completed,
    Failed,
    Cancelled,
}

pub struct SessionArchive {
    pub meta: SessionMeta,
    pub task_graph: Option<TaskGraph>,
    pub events: Vec<HookEvent>,
    pub agents: BTreeMap<String, Agent>,
}

// model/theme.rs
pub struct Theme { /* color constants as ratatui::style::Color */ }
// All colors defined as constants, not configurable (per spec: no config file)
```

### Update Logic (app/update.rs)

Pure function. No I/O. No `async`. Fully unit testable.

```rust
pub fn update(mut state: AppState, event: AppEvent) -> AppState {
    match event {
        AppEvent::TaskGraphUpdated(graph) => {
            state.task_graph = Some(graph);
            state
        }
        AppEvent::TranscriptUpdated { agent_id, messages } => {
            state.agents.entry(agent_id).and_modify(|a| a.messages = messages);
            state
        }
        AppEvent::HookEventReceived(event) => {
            if state.events.len() >= 10_000 {
                state.events.pop_front();
            }
            state.events.push_back(event);
            state
        }
        AppEvent::Key(key) => handle_key(state, key),
        AppEvent::Tick => state, // elapsed timers computed in view from started_at
        // ... other variants
    }
}

fn handle_key(mut state: AppState, key: KeyEvent) -> AppState {
    // Pure navigation logic: view switching, focus, scroll, filter
    // Returns new state, never performs I/O
}
```

### Watcher Layer (watcher/)

Imperative shell. Owns file I/O, emits typed events.

```rust
// watcher/task_graph.rs
pub async fn watch_task_graph(
    path: PathBuf,
    tx: mpsc::Sender<AppEvent>,
) -> Result<()> {
    // 1. Set up notify watcher on path
    // 2. On change (debounced 100ms): read file, parse JSON, emit TaskGraphUpdated
    // 3. On parse error: emit ParseError
}

// watcher/hook_events.rs
pub async fn watch_hook_events(
    path: PathBuf,
    tx: mpsc::Sender<AppEvent>,
) -> Result<()> {
    // 1. Tail events.jsonl (track file position)
    // 2. On new lines: parse each JSON line, emit HookEventReceived
    // 3. Handle file truncation (reset position)
}

// watcher/transcripts.rs
pub async fn watch_transcripts(
    dir: PathBuf,
    tx: mpsc::Sender<AppEvent>,
) -> Result<()> {
    // 1. Watch directory for new agent-*.jsonl files
    // 2. Per file: tail and parse, emit TranscriptUpdated
    // 3. Handle new files appearing (new agents spawning)
}

// watcher/active_agents.rs
pub async fn watch_active_agents(
    dir: PathBuf,
    tx: mpsc::Sender<AppEvent>,
) -> Result<()> {
    // 1. Watch /tmp/claude-subagents/ for *.active files
    // 2. New file: emit AgentStarted
    // 3. File removed: emit AgentStopped
}
```

### View Layer (view/)

Pure rendering. Each function takes `&AppState` and a `Frame` area, produces widgets.

```rust
// view/mod.rs
pub fn render(state: &AppState, frame: &mut Frame) {
    let chunks = Layout::vertical([
        Constraint::Length(1),  // header
        Constraint::Min(0),    // main content
        Constraint::Length(1),  // footer
    ]).split(frame.area());

    header::render(state, frame, chunks[0]);

    if state.show_help {
        help_overlay::render(state, frame, chunks[1]);
    } else {
        match &state.view {
            ViewState::Dashboard => dashboard::render(state, frame, chunks[1]),
            ViewState::AgentDetail { agent_id } => {
                agent_detail::render(state, agent_id, frame, chunks[1]);
            }
            ViewState::Sessions => sessions::render(state, frame, chunks[1]),
        }
    }

    footer::render(state, frame, chunks[2]);

    if let Some(ref filter) = state.filter {
        filter_bar::render(filter, frame); // overlay
    }

    if matches!(state.hook_status, HookStatus::Missing) {
        banner::render_hook_missing(frame); // top banner overlay
    }
}
```

### Archive Layer (archive/)

I/O boundary. Reads/writes session files. Called from main loop, not from update.

```rust
// archive/writer.rs
pub fn save_session(archive: &SessionArchive) -> Result<PathBuf> {
    // Serialize to JSON, write to ~/.local/share/loom-tui/sessions/
}

pub fn auto_save_snapshot(state: &AppState) -> Result<()> {
    // Periodic save of current state for crash resilience
}

// archive/reader.rs
pub fn list_sessions() -> Result<Vec<SessionMeta>> {
    // Scan directory, read metadata from each file header
}

pub fn load_session(id: &str) -> Result<SessionArchive> {
    // Read full session archive from disk
}

pub fn delete_session(id: &str) -> Result<()> {
    // Remove session file from disk
}
```

### Main Event Loop (main.rs)

Imperative shell. Owns tokio runtime, spawns watchers, runs loop.

```rust
#[tokio::main]
async fn main() -> Result<()> {
    color_eyre::install()?;
    let args = Args::parse();  // clap

    let (tx, mut rx) = mpsc::channel::<AppEvent>(256);

    // Spawn watchers (imperative shell)
    let paths = Paths::resolve(&args);
    tokio::spawn(watch_task_graph(paths.task_graph.clone(), tx.clone()));
    tokio::spawn(watch_transcripts(paths.transcripts.clone(), tx.clone()));
    tokio::spawn(watch_hook_events(paths.events.clone(), tx.clone()));
    tokio::spawn(watch_active_agents(paths.active_agents.clone(), tx.clone()));

    // Spawn tick timer
    tokio::spawn(tick_timer(tx.clone(), Duration::from_millis(250)));

    // Spawn keyboard reader
    tokio::spawn(keyboard_reader(tx.clone()));

    // Initialize terminal
    let mut terminal = ratatui::init();
    let mut state = AppState::new();

    // Check hook status
    state.hook_status = hook_install::check_hooks(&paths);

    // Load session list
    state.sessions = archive::reader::list_sessions().unwrap_or_default();

    // Event loop
    loop {
        // Render (pure)
        terminal.draw(|frame| view::render(&state, frame))?;

        // Receive event
        if let Some(event) = rx.recv().await {
            // Handle quit
            if matches!(&event, AppEvent::Key(k) if k.code == KeyCode::Char('q')) {
                break;
            }

            // Handle I/O-triggering actions before pure update
            // (e.g., session load, session delete, hook install)
            handle_side_effects(&state, &event, &tx, &paths).await;

            // Pure update
            state = update(state, event);
        }
    }

    ratatui::restore();
    Ok(())
}
```

---

## Data Flow

```
                                   IMPERATIVE SHELL
                    +------------------------------------------+
                    |                                          |
  .claude/state/    |  task_graph.rs  ----+                   |
  active_task_      |                     |                   |
  graph.json -------->  transcripts.rs ---+                   |
                    |                     |   mpsc channel    |
  agent-*.jsonl ----->  hook_events.rs ---+-------> rx ------>|--+
                    |                     |                   |  |
  events.jsonl ----->  active_agents.rs --+                   |  |
                    |                     |                   |  |
  keyboard -------->  keyboard_reader ----+                   |  |
                    |                                          |  |
  250ms timer ----->  tick_timer ---------+                   |  |
                    |                                          |  |
                    +------------------------------------------+  |
                                                                  |
                               FUNCTIONAL CORE                    |
                    +------------------------------------------+  |
                    |                                          |  |
                    |  state = update(state, event)  <--------+  |
                    |       ^                                    |
                    |       | pure fn, no I/O                    |
                    |       v                                    |
                    |  view::render(&state, frame)               |
                    |       |                                    |
                    |       | pure fn, produces widget tree      |
                    |       v                                    |
                    |  ratatui Frame (to terminal)               |
                    |                                          |
                    +------------------------------------------+

                               I/O BOUNDARIES
                    +------------------------------------------+
                    |  archive::writer  (periodic auto-save)   |
                    |  archive::reader  (session load/list)    |
                    |  hook_install     (check/install hooks)  |
                    +------------------------------------------+
```

**Sequence for file change:**
1. `notify` detects file modification (inotify/FSEvents)
2. Watcher debounces (100ms), reads file, parses to domain model
3. Watcher sends typed `AppEvent` through mpsc channel
4. Main loop receives event, calls pure `update(state, event)`
5. Main loop calls pure `view::render(&state, frame)`
6. ratatui renders frame to terminal via crossterm

**Sequence for keyboard input:**
1. crossterm reads key event from stdin
2. Keyboard reader sends `AppEvent::Key(key)` through channel
3. Main loop: `update(state, Key(key))` -> pure navigation logic
4. Render updated view

**Sequence for session archive (I/O triggered):**
1. `update()` returns new state but does NOT perform I/O
2. `handle_side_effects()` in main loop checks if action requires I/O
3. E.g., user pressed Enter on session -> `archive::reader::load_session()`
4. Result sent back as `AppEvent::SessionLoaded` through channel
5. Next loop iteration: `update(state, SessionLoaded(data))`

---

## Implementation Phases

### Phase 1: Foundation (zero dependencies between items)

**Wave 1 -- all items run in parallel:**

| Task | Description | Files |
|------|-------------|-------|
| P1-T1 | Project scaffold: Cargo.toml, flake.nix, src/main.rs stub, src/lib.rs | `Cargo.toml`, `flake.nix`, `src/main.rs`, `src/lib.rs` |
| P1-T2 | Domain models: all types in model/ (task, agent, hook_event, session, theme) with serde derives and constructors. Include test fixtures. | `src/model/*.rs`, `tests/fixtures/*` |
| P1-T3 | AppEvent enum + AppState struct + constructors | `src/event/mod.rs`, `src/app/state.rs`, `src/app/mod.rs` |
| P1-T4 | Path resolution module | `src/paths.rs` |

### Phase 2: Core Logic (depends on Phase 1)

**Wave 2 -- all items run in parallel:**

| Task | Description | Files |
|------|-------------|-------|
| P2-T1 | Pure update logic: `update(state, event) -> state` for all AppEvent variants. Full unit test coverage with fixture data. | `src/app/update.rs`, `tests/update_tests.rs` |
| P2-T2 | Pure navigation logic: view switching (1/2/3), focus (Tab/h/l), scroll (j/k), drill-down (Enter), back (Esc), quit (q), filter (/), help (?), auto-scroll (Space). Unit tests for all key combos. | `src/app/navigation.rs`, `tests/navigation_tests.rs` |
| P2-T3 | Hook script: `send_event.sh` supporting all 9 event types, outputting JSON lines. Hook install detection + installation logic. | `hooks/send_event.sh`, `src/hook_install/mod.rs` |

### Phase 3: I/O Layer (depends on Phase 1 models)

**Wave 3 -- all items run in parallel:**

| Task | Description | Files |
|------|-------------|-------|
| P3-T1 | File watchers: task_graph, transcripts, hook_events, active_agents. Debounced notify watchers that parse files and emit AppEvents. Integration tests with temp files. | `src/watcher/*.rs`, `tests/watcher_integration.rs` |
| P3-T2 | Session archive: writer (save/auto-save), reader (list/load/delete). Integration tests with temp directories. | `src/archive/*.rs`, `tests/archive_integration.rs` |

### Phase 4: View Layer (depends on Phase 1 models + Phase 2 state)

**Wave 4 -- all items run in parallel:**

| Task | Description | Files |
|------|-------------|-------|
| P4-T1 | Dashboard view: header, footer, wave_river widget, task_list widget, event_stream widget. Layout with 35/65 split. Banner component. | `src/view/dashboard.rs`, `src/view/components/{header,footer,wave_river,task_list,event_stream,banner}.rs` |
| P4-T2 | Agent detail view: tool_call_list widget, reasoning_panel widget. Layout with 55/45 split. Toggle/wide mode rendering. | `src/view/agent_detail.rs`, `src/view/components/{tool_call_list,reasoning_panel}.rs` |
| P4-T3 | Sessions view + shared overlays: session_table widget, filter_bar overlay, help_overlay. View dispatch in view/mod.rs. | `src/view/sessions.rs`, `src/view/mod.rs`, `src/view/components/{session_table,filter_bar,help_overlay}.rs` |

### Phase 5: Integration (depends on all previous phases)

**Wave 5 -- sequential:**

| Task | Description | Files |
|------|-------------|-------|
| P5-T1 | Main event loop: wire watchers + keyboard + tick into mpsc channel, connect to update + render. Side effect dispatch. Terminal init/restore. CLI args with clap. | `src/main.rs` |
| P5-T2 | End-to-end smoke tests: launch app with fixture data, verify no panics, verify render output. Performance benchmarks for NFR targets. | `tests/e2e_tests.rs` (if feasible), manual test plan |

---

## Testing Strategy

### Unit Tests (90%+ coverage target)

**Update logic** (`tests/update_tests.rs`):
- Given initial state + `TaskGraphUpdated` event -> assert task_graph field set correctly
- Given state with 10,000 events + new event -> assert oldest evicted, newest added
- Given state + `Key('1')` -> assert view switches to Dashboard
- Given state + `Key('q')` -> assert quit signal (tested via return value or flag)
- Property test: update never panics for any valid (state, event) combination
- Property test: event buffer never exceeds 10,000

**Navigation logic** (`tests/navigation_tests.rs`):
- Given Dashboard + Tab -> focus switches Left <-> Right
- Given Dashboard + Enter on task with agent -> view transitions to AgentDetail
- Given AgentDetail + Esc -> view transitions back to Dashboard
- Given any view + '1'/'2'/'3' -> correct ViewState
- Given scrolled position + 'j' -> scroll offset increments (bounded)

**Model parsing** (`tests/model_tests.rs`):
- Parse valid `active_task_graph.json` fixture -> correct TaskGraph
- Parse valid `agent-*.jsonl` fixture -> correct Agent with messages
- Parse valid `events.jsonl` lines -> correct HookEvent variants
- Parse malformed JSON -> Result::Err, not panic
- Property test: serialize then deserialize = identity for all model types

### Integration Tests (I/O boundaries only)

**Watcher tests** (`tests/watcher_integration.rs`):
- Write fixture file to temp dir -> watcher emits correct AppEvent within 500ms
- Overwrite file rapidly -> debounce produces single event
- Write malformed file -> ParseError event emitted, no crash
- Delete watched file -> graceful handling

**Archive tests** (`tests/archive_integration.rs`):
- Save session archive -> file exists with correct JSON
- List sessions from directory -> correct SessionMeta vec
- Load session by id -> correct SessionArchive
- Delete session -> file removed
- Handle empty directory -> empty vec, no error

### View Tests (`tests/view_tests.rs`)

- Render dashboard with sample state -> buffer contains expected task text, wave indicators
- Render agent detail -> buffer contains tool call entries
- Render sessions -> buffer contains session table rows
- Render with empty state -> no panic, shows placeholder text

---

## Verification

| Criterion | How to Verify |
|-----------|---------------|
| SC-001: Launch and see session in 2s | Manual test: `time loom-tui` with active session |
| SC-002: 500ms update latency | Integration test: write file, measure time to AppEvent receipt |
| SC-003: Tool calls with timestamps | Unit test: parse fixture transcript, assert all tool calls present |
| SC-004: Navigate without docs | Manual test: keybindings in footer for every view |
| SC-005: Historical sessions load | Integration test: save then load session archive |
| SC-006: Zero crashes on valid files | Run with 10 real loom session fixtures, assert no panics |
| SC-007: 90%+ unit testable | Code audit: count lines in pure vs I/O modules |

---

## Security Considerations

- **File paths:** All paths derived from known locations (`$TMPDIR`, `~/.local/share/`, `.claude/state/`). No user-supplied paths beyond CLI args for project root. No path traversal risk.
- **Hook script:** Bash script appends to known file. No network access. No secrets in events (tool call summaries only, not full content).
- **Archive files:** JSON only. No code execution from archived data. serde deserialization is safe against malicious JSON (no arbitrary code execution).
- **No network:** Entirely local filesystem. No listening sockets, no HTTP.

## Non-Functional Impact

- **Performance:** VecDeque ring buffer keeps memory bounded. Debounced watchers prevent CPU spikes. Pure render at 4Hz tick rate is well within 100ms budget.
- **Resilience:** Parse errors are non-fatal. Watcher errors trigger reconnect. Missing files show empty state.
- **Observability:** Internal error buffer in AppState visible in status bar. Errors are accumulated, not lost.
- **Extensibility:** Adding new views = new ViewState variant + render function. Adding new event types = new AppEvent variant + update handler. Elm Architecture scales linearly.

---

## Unresolved Questions

- Nix flake: use `crane` or `naersk` for Rust build?
- Hook script: exact JSON schema for each of 9 event types? Need real examples from Claude Code hooks
- Task graph JSON: exact schema of `active_task_graph.json`? Need sample from real loom session
- Agent transcript JSONL: exact line format? Need sample from real session
- Auto-save interval: how often to snapshot for crash resilience? 30s? 60s?
